#include <stdio.h>

/*
 *  计算机内存包含   栈区，堆区， 静态区， 代码区 
 *     
 *        代码区：代码区code，程序被操作系统加载到内存的时候，所有的可执行代码都加载到代码区，也叫代码段，这块内存是不可以在运行期间修改的。
 *
 *        静态区：所有的全局变量以及程序中的静态变量都存储到静态区。  内存内容一直有效。 
 *
 *        栈区： 栈 stack  是一种先进后出的内存结构，所有的自动变量，函数的形参都是由编译器自动放入栈中，当一个自动变量超出其作用域时，自动从栈中弹出 
 *                       对于自动变量，什么时候入栈，什么时候出栈，是不需要程序控制的。由C语言编译器实现。 
 * 
 *       栈溢出： 当栈空间已满，但是还往栈内存压变量，这个就叫栈溢出。
 *            对于一个 32 位操作系统，最大管理 4G 内存，其中 1G 是给操作系统自己用的。剩下的 3G 都是给用户程序。一个用户程序理论上可以使用 3G 的内存空间 
 *   
 *       堆区： 堆 heap 和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进先出的顺序。
 *                      堆是一个大容器，它的容量要远远大于栈，但是在C语言中，堆内存空间的申请和释放需要手动通过代码来完成。
 *						堆内存的分配和释放     malloc     free  
 */

extern int age;  //有一个变量，类型是int，名字是age， 已经在其他的文件中定义了，这里就直接引用。

int age;  //有2个含义： 1.声明一个变量； 2.定义一个变量 

int c = 0;   //全局变量  -- 静态区 

int *geta()  //函数的返回值是一个指针 
{
	auto int a = 100;
	return &a;
 }   // int a的作用域就是这个{} 

void test(int a, int b)
{
	printf("%d, %d\n", &a, &b); //在栈区 
}

int main(void)   // 在代码区 
{
	int *p = geta();   //这里得到一个临时的栈变量的地址，这个地址在函数geta调用完成之后已经无效了。 
	*p = 100;
	printf("%d\n", *p);
	
	int a = 0;   // 在栈区 
	auto int b = 0;
	static int d = 0;  //静态变量  -- 静态区 
	
	printf("%d, %d, %d, %d, %d\n", &a, &b, &c, &d, main);
	test(a,b);
	return 0;
}

